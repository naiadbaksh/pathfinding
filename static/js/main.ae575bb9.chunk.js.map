{"version":3,"sources":["mazes/horizontalMaze.jsx","mazes/verticalMaze.jsx","reportWebVitals.js","pathfindingVisualizer/Node/node.component.jsx","pathfindingVisualizer/toolbar.component.jsx","algorithms/dijkstra.jsx","algorithms/astar.jsx","algorithms/breadthFirstSearch.jsx","algorithms/depthFirstSearch.jsx","algorithms/greedyBestFirstSearch.jsx","algorithms/bidirectionalGreedySearch.jsx","algorithms/randomWalk.jsx","mazes/recursiveDivision.jsx","pathfindingVisualizer/pathfindingVisualizer.component.jsx","mazes/randomMaze.jsx","index.js"],"names":["walls","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Node","cellHeight","row","col","isStart","isEnd","isWall","isVisited","isShortest","width","height","numRows","numCols","onMouseDown","onMouseUp","onMouseEnter","classes","cellWidth","Math","floor","id","className","style","Toolbar","props","useState","algorithm","setAlgorithm","maze","setMaze","pathState","setPathState","mazeState","setMazeState","speedState","setSpeedState","selectAlgorithm","selection","visualizing","clearPath","selectMaze","creatingMaze","clearTemp","clearGrid","changeSpeed","speed","value","updateSpeed","type","onClick","visualizeDijkstra","visualizeAStar","visualizeGreedyBFS","visualizeBidirectionalGreedySearch","visualizeBFS","visualizeDFS","visualizeRandomWalk","generateRandomMaze","generateRecursiveDivisionMaze","generateVerticalMaze","generateHorizontalMaze","getNodes","grid","nodes","node","push","updateUnvisitedNeighbours","unvisitedNeighbours","getUnvisitedNeighbours","unvisitedNeighbour","distance","previousNode","neighbours","length","filter","neighbour","getNeighbours","neighbourNotInUnvisitedNodes","unvisitedNodes","manhattanDistance","endNode","abs","nodeA","nodeB","isNeighbour","closestNodeStart","closestNodeEnd","startRow","startCol","endRow","endCol","getRandomNeighbour","filteredNeighbours","neighboursNotVisited","random","numNodesVisited","count","range","len","result","i","getHorizontalWalls","vertical","horizontal","startNode","choice","num","addWall","isStartorEnd","tempWalls","temp","splice","wall","verticalMaze","getVerticalWalls","dir","isStartOrEnd","generateRandomNumber","getRecursiveWalls","generateOddRandomNumber","slice","indexOf","array","max","randomNum","getIncrements","increments1","increments2","createInitialGrid","currentRow","createNode","initialMeasurements","getGridMeasurements","window","innerWidth","innerHeight","initialNumRows","initialNumCols","startAndEndNode","increments","x","y","startNodeRow","startNodeCol","endNodeRow","endNodeCol","getStartAndEndNode","Infinity","totalDistance","PathfindingVisualizer","setGrid","setWidth","setHeight","setSpeed","mouseIsPressed","setMouseIsPressed","mazeSpeed","setMazeSpeed","setVisualizing","setCreatingMaze","getDimensions","newGridWithWalls","newGrid","newNode","useEffect","addEventListener","document","getElementById","animateShortestPath","nodesInShortestPathOrder","visitedNodesInOrder","setTimeout","updateNodesForRender","animateAlgorithm","animateBidirectionalAlgorithm","visitedNodesInOrderStart","visitedNodesInOrderEnd","isShortedPath","longest","undefined","getVisitedNodesInOrder","animateMaze","newGridWithMaze","sort","a","b","closestNode","shift","dijkstra","nodesInShortestPathInOrder","currentNode","unshift","getNodesInShortestPathOrderDijkstra","aStar","getNodesInShortestPathOrderAStar","greedyBestFirstSearch","getNodesInShortestPathOrderGBFS","depthFirstSearch","getNodesInShortestPathOrderDFS","breadthFirstSearch","getNodesInShortestPathOrderBFS","unvisitedNodesStart","unvisitedNodesEnd","bidirectionalGreedySearch","getNodesInShortestPathOrderBGS","animateRandomWalk","maxNodes","maxNodesVisitedCounter","loopCounter","randomNeighbour","nodesVisited","randomWalk","randomMaze","horizontalMaze","recursiveDivisionMaze","getGridWithoutPath","path","map","rowId","nodeId","console","log","handleMouseDown","handleMouseEnter","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ae575bb9.chunk.js","sourcesContent":["let walls;\nexport const horizontalMaze = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, endNode);\n  return walls;\n};\n\nconst range = (len) => {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst getHorizontalWalls = (vertical, horizontal, startNode, endNode) => {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, endNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, endNode);\n    }\n  }\n};\n\nconst addWall = (num, vertical, startNode, endNode) => {\n  let isStartorEnd = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === endNode.row && temp === endNode.col)\n    ) {\n      isStartorEnd = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartorEnd) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n};\n","let walls;\nexport const verticalMaze = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, endNode);\n  return walls;\n};\n\nconst range = (len) => {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nfunction getVerticalWalls(vertical, horizontal, startNode, endNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, endNode);\n    }\n  }\n}\n\nconst addWall = (num, horizontal, startNode, endNode) => {\n  let isStartorEnd = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === endNode.row && num === endNode.col)\n    ) {\n      isStartorEnd = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartorEnd) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n};\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport \"./node.styles.css\";\n\nconst Node = ({\n  row,\n  col,\n  isStart,\n  isEnd,\n  isWall,\n  isVisited,\n  isShortest,\n  width,\n  height,\n  numRows,\n  numCols,\n  onMouseDown,\n  onMouseUp,\n  onMouseEnter,\n}) => {\n  //Extra classes to add to the nodes using conditional rendering\n  const classes = isStart\n    ? \"node node-start\"\n    : isEnd\n    ? \"node node-end\"\n    : isWall\n    ? \"node-wall\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : isVisited\n    ? \"node node-visited\"\n    : \"node\";\n\n  // Conditions for responsiveness\n  let cellWidth = Math.floor((width - 15) / numCols);\n  let cellHeight;\n  if (width > 1500) {\n    cellHeight = Math.floor((height - 70) / numRows);\n  } else if (width > 1000) {\n    cellHeight = Math.floor((height - 70) / numRows);\n  } else if (width > 500) {\n    cellHeight = Math.floor((height - 60) / numRows);\n  } else if (width > 0) {\n    cellHeight = Math.floor((height - 50) / numRows);\n  }\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`${classes}`}\n      style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n      onMouseDown={() => onMouseDown(row, col)}\n      onMouseEnter={() => onMouseEnter(row, col)}\n      onMouseUp={() => onMouseUp()}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React, { useState } from \"react\";\nimport \"./toolbar.styles.css\";\n\nconst Toolbar = (props) => {\n  // State\n  const [algorithm, setAlgorithm] = useState(\"Visualize Algorithm\");\n  const [maze, setMaze] = useState(\"Generate Maze\");\n  const [pathState, setPathState] = useState(false);\n  const [mazeState, setMazeState] = useState(false);\n  const [speedState, setSpeedState] = useState(\"Speed\");\n\n  const selectAlgorithm = (selection) => {\n    if (props.visualizing) {\n      return;\n    }\n    if (\n      selection === algorithm ||\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm\"\n    ) {\n      setAlgorithm(selection);\n    } else if (pathState) {\n      clearPath();\n      setAlgorithm(selection);\n    } else {\n      setAlgorithm(selection);\n    }\n  };\n\n  const selectMaze = (selection) => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    if (\n      selection === maze ||\n      maze === \"Generate Maze\" ||\n      maze === \"Select a Maze\"\n    ) {\n      setMaze(selection);\n    } else if (pathState) {\n      clearPath();\n      setMaze(selection);\n    } else {\n      setMaze(selection);\n    }\n  };\n\n  const visualizeAlgorithm = () => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    if (pathState) {\n      clearTemp();\n      return;\n    }\n    if (\n      algorithm === \"Visualize Algorithm\" ||\n      algorithm === \"Select an Algorithm\"\n    ) {\n      setAlgorithm(\"Select an Algorithm\");\n    } else {\n      setPathState(true);\n      if (algorithm === \"Visualize Dijkstra\") {\n        props.visualizeDijkstra();\n      } else if (algorithm === \"Visualize A*\") {\n        props.visualizeAStar();\n      } else if (algorithm === \"Visualize Greedy BFS\") {\n        props.visualizeGreedyBFS();\n      } else if (algorithm === \"Visualize Bidirectional Greedy\") {\n        props.visualizeBidirectionalGreedySearch();\n      } else if (algorithm === \"Visualize Breadth First Search\") {\n        props.visualizeBidirectionalGreedySearch();\n      } else if (algorithm === \"Visualize Breadth First Search\") {\n        props.visualizeBFS();\n      } else if (algorithm === \"Visualize Depth First Search\") {\n        props.visualizeDFS();\n      } else if (algorithm === \"Visualize Depth First Search\") {\n        props.visualizeDFS();\n      } else if (algorithm === \"Visualize Random Walk\") {\n        props.visualizeRandomWalk();\n      }\n    }\n  };\n\n  const generateMaze = () => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    if (mazeState || pathState) {\n      clearTemp();\n    }\n    if (maze === \"Generate Maze\" || maze === \"Select a Maze\") {\n      setMaze(\"Select a Maze\");\n    } else {\n      setMazeState(true);\n      if (maze === \"Generate Random Maze\") {\n        props.generateRandomMaze();\n      } else if (maze === \"Generate Recursive Maze\") {\n        props.generateRecursiveDivisionMaze();\n      } else if (maze === \"Generate Vertical Maze\") {\n        props.generateVerticalMaze();\n      } else if (maze === \"Generate Horizontal Maze\") {\n        props.generateHorizontalMaze();\n      }\n    }\n  };\n\n  const clearGrid = () => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setAlgorithm(\"Visualize Algorithm\");\n    setMaze(\"Generate Maze\");\n    setPathState(false);\n    setMazeState(false);\n  };\n\n  const clearPath = () => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    props.clearPath();\n    setPathState(false);\n    setMazeState(false);\n  };\n\n  const clearTemp = () => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    props.clearGrid();\n    setPathState(false);\n    setMazeState(false);\n  };\n\n  const changeSpeed = (speed) => {\n    if (props.visualizing || props.creatingMaze) {\n      return;\n    }\n    let value = [10, 10];\n    if (speed === \"Slow\") value = [50, 30];\n    else if (speed === \"Medium\") value = [25, 20];\n    else if (speed === \"Fast\") value = [10, 10];\n    setSpeedState(speed);\n    props.updateSpeed(value[0], value[1]);\n  };\n\n  return (\n    <nav className=\"navbar navbar-expand navbar-dark bg-dark\">\n      <div className=\"navbar-collapse\" id=\"navbarNavDrop\">\n        <ul className=\"navbar-nav\">\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <button\n                className=\"btn btn-light dropdown-toggle\"\n                type=\"button\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Algorithms\n              </button>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectAlgorithm(\"Visualize Dijkstra\")}\n                >\n                  Dijkstra's Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectAlgorithm(\"Visualize A*\")}\n                >\n                  A* Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectAlgorithm(\"Visualize Greedy BFS\")}\n                >\n                  Greedy BFS Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Bidirectional Greedy\")\n                  }\n                >\n                  Bidirectional Greedy Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Breadth First Search\")\n                  }\n                >\n                  Breadth First Search Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() =>\n                    selectAlgorithm(\"Visualize Depth First Search\")\n                  }\n                >\n                  Depth First Search Algorithm\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectAlgorithm(\"Visualize Random Walk\")}\n                >\n                  Random Walk\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n          <li>\n            <button\n              type=\"button\"\n              className=\"btn btn-success\"\n              onClick={() => visualizeAlgorithm()}\n            >\n              {algorithm}\n            </button>\n          </li>\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <button\n                className=\"btn btn-light dropdown-toggle\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                Mazes\n              </button>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Random Maze\")}\n                >\n                  Random Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Recursive Maze\")}\n                >\n                  Recursive Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Vertical Maze\")}\n                >\n                  Vertical Maze\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => selectMaze(\"Generate Horizontal Maze\")}\n                >\n                  Horizontal Maze\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n          <li>\n            <button\n              className=\"btn btn-success\"\n              type=\"button\"\n              onClick={() => generateMaze()}\n            >\n              {maze}\n            </button>\n          </li>\n          <li>\n            <button\n              className=\"btn btn-danger\"\n              type=\"button\"\n              onClick={() => clearGrid()}\n            >\n              Clear Grid\n            </button>\n          </li>\n          <li className=\"nav-item dropdown\">\n            <div className=\"dropdown\">\n              <button\n                className=\"btn btn-info droptown-toggle\"\n                type=\"button\"\n                id=\"dropdownMenu1\"\n                data-toggle=\"dropdown\"\n                aria-haspopup=\"true\"\n                aria-expanded=\"false\"\n              >\n                {speedState}\n              </button>\n              <div className=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Slow\")}\n                >\n                  Slow\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Medium\")}\n                >\n                  Medium\n                </button>\n                <button\n                  className=\"dropdown-item btn-light\"\n                  type=\"button\"\n                  onClick={() => changeSpeed(\"Fast\")}\n                >\n                  Fast\n                </button>\n              </div>\n            </div>{\" \"}\n          </li>\n        </ul>\n      </div>\n    </nav>\n  );\n};\n\nexport default Toolbar;\n","export const dijkstra = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  startNode.distance = 0;\n  let unvisitedNodes = getNodes(grid);\n  let visitedNodesInOrder = [];\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.distance - b.distance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    if (closestNode === endNode) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    updateUnvisitedNeighbours(closestNode, grid);\n  }\n};\n\nconst getNodes = (grid) => {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst updateUnvisitedNeighbours = (node, grid) => {\n  let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n  for (let unvisitedNeighbour of unvisitedNeighbours) {\n    unvisitedNeighbour.distance = node.distance + 1;\n    unvisitedNeighbour.previousNode = node;\n  }\n};\n\nconst getUnvisitedNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isVisited && !neighbour.isWall\n  );\n};\n\nexport const getNodesInShortestPathOrderDijkstra = (endNode) => {\n  let nodesInShortestPathInOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathInOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathInOrder;\n};\n","export const aStar = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let unvisitedNodes = []; // Open List\n  let visitedNodesInOrder = []; // Closed List\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    let neighbours = getNeighbours(closestNode, grid);\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1;\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance =\n          distance + manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n  );\n};\n\nconst neighbourNotInUnvisitedNodes = (neighbour, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n};\n\nconst manhattanDistance = (node, endNode) => {\n  let x = Math.abs(node.row - endNode.row);\n  let y = Math.abs(node.col - endNode.col);\n  return x + y;\n};\n\nexport const getNodesInShortestPathOrderAStar = (endNode) => {\n  let nodesInShortestPathInOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathInOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathInOrder;\n};\n","export const breadthFirstSearch = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === endNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n        unvisitedNodes.push(unvisitedNeighbour);\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n};\n\nconst neighbourNotInUnvisitedNodes = (neighbour, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const getNodesInShortestPathOrderBFS = (endNode) => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n","export const depthFirstSearch = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode === endNode) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    closestNode.isVisited = true;\n    let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.previousNode = closestNode;\n      unvisitedNodes.unshift(unvisitedNeighbour);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getUnvisitedNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n};\n\nexport const getNodesInShortestPathOrderDFS = (endNode) => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n","export const greedyBestFirstSearch = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let unvisitedNodes = [];\n  let visitedNodesInOrder = [];\n  startNode.distance = 0;\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length !== 0) {\n    unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNode = unvisitedNodes.shift();\n    if (closestNode === endNode) return visitedNodesInOrder;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n\n    let neighbours = getNeighbours(closestNode, grid);\n    for (let neighbour of neighbours) {\n      let distance = closestNode.distance + 1;\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n        unvisitedNodes.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNode;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNode;\n      }\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nconst getNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n  );\n};\n\nconst manhattanDistance = (nodeA, nodeB) => {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n};\n\nconst neighbourNotInUnvisitedNodes = (neighbour, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const getNodesInShortestPathOrderGBFS = (endNode) => {\n  let nodesInShortestPathInOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathInOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathInOrder;\n};\n","export const bidirectionalGreedySearch = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let unvisitedNodesStart = [];\n  let visitedNodesInOrderStart = [];\n  let unvisitedNodesEnd = [];\n  let visitedNodesInOrderEnd = [];\n  startNode.distance = 0;\n  endNode.distance = 0;\n  unvisitedNodesStart.push(startNode);\n  unvisitedNodesEnd.push(endNode);\n\n  while (unvisitedNodesStart.length !== 0 && unvisitedNodesEnd.length !== 0) {\n    unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n    unvisitedNodesEnd.sort((a, b) => a.totalDistance - b.totalDistance);\n    let closestNodeStart = unvisitedNodesStart.shift();\n    let closestNodeEnd = unvisitedNodesEnd.shift();\n\n    closestNodeStart.isVisited = true;\n    closestNodeEnd.isVisited = true;\n    visitedNodesInOrderStart.push(closestNodeStart);\n    visitedNodesInOrderEnd.push(closestNodeEnd);\n    if (isNeighbour(closestNodeStart, closestNodeEnd)) {\n      return [visitedNodesInOrderStart, visitedNodesInOrderEnd, true];\n    }\n\n    // Start side search\n    let neighbours = getNeighbours(closestNodeStart, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesEnd)) {\n        visitedNodesInOrderStart.push(closestNodeStart);\n        visitedNodesInOrderEnd.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderEnd, true];\n      }\n      let distance = closestNodeStart.distance + 1;\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        unvisitedNodesStart.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNodeStart;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, endNode);\n        neighbour.previousNode = closestNodeStart;\n      }\n    }\n\n    // End side search\n    neighbours = getNeighbours(closestNodeEnd, grid);\n    for (let neighbour of neighbours) {\n      if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n        visitedNodesInOrderStart.push(closestNodeEnd);\n        visitedNodesInOrderEnd.push(neighbour);\n        return [visitedNodesInOrderStart, visitedNodesInOrderEnd, true];\n      }\n      let distance = closestNodeEnd.distance + 1;\n      if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesEnd)) {\n        unvisitedNodesEnd.unshift(neighbour);\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeEnd;\n      } else if (distance < neighbour.distance) {\n        neighbour.distance = distance;\n        neighbour.totalDistance = manhattanDistance(neighbour, startNode);\n        neighbour.previousNode = closestNodeEnd;\n      }\n    }\n  }\n  return [visitedNodesInOrderStart, visitedNodesInOrderEnd, false];\n};\n\nconst isNeighbour = (closestNodeStart, closestNodeEnd) => {\n  let startRow = closestNodeStart.row;\n  let startCol = closestNodeStart.col;\n  let endRow = closestNodeEnd.row;\n  let endCol = closestNodeEnd.col;\n  if (endRow === startRow - 1 && endCol === startCol) return true;\n  if (endRow === startRow - 1 && endCol === startCol + 1) return true;\n  if (endRow === startRow + 1 && endCol === startCol) return true;\n  if (endRow === startRow && endCol === startCol - 1) return true;\n  return false;\n};\n\nconst getNeighbours = (node, grid) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  return neighbours.filter(\n    (neighbour) => !neighbour.isWall && !neighbour.isVisited\n  );\n};\n\nconst manhattanDistance = (nodeA, nodeB) => {\n  let x = Math.abs(nodeA.row - nodeB.row);\n  let y = Math.abs(nodeA.col - nodeB.col);\n  return x + y;\n};\n\nconst neighbourNotInUnvisitedNodes = (neighbour, unvisitedNodes) => {\n  for (let node of unvisitedNodes) {\n    if (node.row === neighbour.row && node.col === neighbour.col) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const getNodesInShortestPathOrderBGS = (nodeA, nodeB) => {\n  let nodesInShortestPathOrder = [];\n  let currentNode = nodeB;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.push(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  currentNode = nodeA;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\n","export const randomWalk = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let visitedNodesInOrder = [];\n  let closestNode = startNode;\n  let maxNodes = grid.length * grid[0].length;\n  let maxNodesVisitedCounter = 0;\n  let loopCounter = 0;\n  while (true) {\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === endNode) return visitedNodesInOrder;\n    let randomNeighbour = getRandomNeighbour(closestNode, grid, endNode);\n    let nodesVisited = numNodesVisited(grid);\n    if (nodesVisited === maxNodes - 2) {\n      return visitedNodesInOrder;\n    }\n    if (nodesVisited > maxNodesVisitedCounter) {\n      maxNodesVisitedCounter = nodesVisited;\n      loopCounter = 0;\n    } else if ((nodesVisited = maxNodesVisitedCounter)) {\n      loopCounter += 1;\n      if (loopCounter > 1000) {\n        return visitedNodesInOrder;\n      }\n    }\n    randomNeighbour.previousNode = closestNode;\n    closestNode = randomNeighbour;\n  }\n};\n\nconst getRandomNeighbour = (node, grid, endNode) => {\n  let neighbours = [];\n  let { row, col } = node;\n  if (row !== 0) neighbours.push(grid[row - 1][col]);\n  if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n  if (col !== 0) neighbours.push(grid[row][col - 1]);\n  let filteredNeighbours = neighbours.filter(\n    (neighbour) => !neighbour.isStart && !neighbour.isWall\n  );\n  let neighboursNotVisited = filteredNeighbours.filter(\n    (neighbour) => !neighbour.isVisited\n  );\n  if (neighboursNotVisited.length > 0) {\n    return neighboursNotVisited[\n      Math.floor(Math.random() * neighboursNotVisited.length)\n    ];\n  }\n  return filteredNeighbours[\n    Math.floor(Math.random() * filteredNeighbours.length)\n  ];\n};\n\nconst numNodesVisited = (grid) => {\n  let count = 0;\n  for (let row in grid) {\n    for (let node in row) {\n      if (node.isVisited || node.isWall) count += 1;\n    }\n  }\n  return count;\n};\n","let walls;\n\nexport const recursiveDivisionMaze = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, endNode);\n  return walls;\n};\n\nconst range = (len) => {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n};\n\nconst addWall = (dir, num, vertical, horizontal, startNode, endNode) => {\n  let isStartOrEnd = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === endNode.row && num === endNode.col)\n      ) {\n        isStartOrEnd = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === endNode.row && temp === endNode.col)\n      ) {\n        isStartOrEnd = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartOrEnd) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n};\n\nconst getRecursiveWalls = (vertical, horizontal, grid, startNode, endNode) => {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, endNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      endNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      endNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, endNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      endNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      endNode\n    );\n  }\n};\n\nconst generateOddRandomNumber = (array) => {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n};\n\nconst generateRandomNumber = (max) => {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n};\n\n// 0 = Horizontal, 1 = Vertical\n","import React, { useState, useEffect } from \"react\";\nimport \"./pathfindingVisualizer.styles.css\";\nimport Node from \"./Node/node.component\";\nimport ToolBar from \"./toolbar.component\";\n\n// Import Pathfinding Algorithms\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"../algorithms/dijkstra\";\nimport { aStar, getNodesInShortestPathOrderAStar } from \"../algorithms/astar\";\nimport {\n  breadthFirstSearch,\n  getNodesInShortestPathOrderBFS,\n} from \"../algorithms/breadthFirstSearch\";\nimport {\n  depthFirstSearch,\n  getNodesInShortestPathOrderDFS,\n} from \"../algorithms/depthFirstSearch\";\nimport {\n  greedyBestFirstSearch,\n  getNodesInShortestPathOrderGBFS,\n} from \"../algorithms/greedyBestFirstSearch\";\nimport {\n  bidirectionalGreedySearch,\n  getNodesInShortestPathOrderBGS,\n} from \"../algorithms/bidirectionalGreedySearch\";\nimport { randomWalk } from \"../algorithms/randomWalk\";\n\n// Import Maze Algorithms\nimport { randomMaze } from \"../mazes/randomMaze\";\nimport { horizontalMaze } from \"../mazes/horizontalMaze\";\nimport { verticalMaze } from \"../mazes/verticalMaze\";\nimport { recursiveDivisionMaze } from \"../mazes/recursiveDivision\";\n\n// Functions to get the beginnings of our grid\nconst getGridMeasurements = (width, height) => {\n  let numCols;\n  if (width > 1500) {\n    numCols = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numCols = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numCols = Math.floor(width / 20);\n  } else if (width > 750) {\n    numCols = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numCols = Math.floor(width / 15);\n  } else if (width > 250) {\n    numCols = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numCols = Math.floor(width / 10);\n  }\n  let cellWidth = Math.floor(width / numCols);\n  let numRows = Math.floor(height / cellWidth);\n  return [numRows, numCols];\n};\n\n// Get increments used in the start and end nodes\nconst getIncrements = (num) => {\n  let increments1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    increments1.push(temp);\n    temp += 2;\n  }\n  let increments2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    increments2.push(temp);\n    temp -= 2;\n  }\n  return [increments1, increments2];\n};\n\n// Getting the start and end node using random numbers\nconst getStartAndEndNode = (numRows, numCols) => {\n  let increments;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let endNodeRow;\n  let endNodeCol;\n  if (numRows < numCols) {\n    increments = getIncrements(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numCols / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + increments[1][Math.floor(Math.random() * increments[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    endNodeRow =\n      x + increments[0][Math.floor(Math.random() * increments[0].length)];\n    endNodeCol = numCols - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    increments = getIncrements(numCols);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numCols / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (x % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + increments[1][Math.floor(Math.random() * increments[1].length)];\n    endNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    endNodeCol =\n      y + increments[0][Math.floor(Math.random() * increments[0].length)];\n  }\n  return [startNodeRow, startNodeCol, endNodeRow, endNodeCol];\n};\n\n// Creating the initial grid with number of rows and columns\nconst createInitialGrid = (numRows, numCols) => {\n  let grid = [];\n  for (let row = 0; row < numRows; row++) {\n    let currentRow = [];\n    for (let col = 0; col < numCols; col++) {\n      currentRow.push(createNode(row, col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// Grid constants\nconst initialMeasurements = getGridMeasurements(\n  window.innerWidth,\n  window.innerHeight\n);\nconst initialNumRows = initialMeasurements[0];\nconst initialNumCols = initialMeasurements[1];\n\nconst startAndEndNode = getStartAndEndNode(initialNumRows, initialNumCols);\nconst startNodeRow = startAndEndNode[0];\nconst startNodeCol = startAndEndNode[1];\nconst endNodeRow = startAndEndNode[2];\nconst endNodeCol = startAndEndNode[3];\n\n// Node constructor\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === startNodeRow && col === startNodeCol,\n    isEnd: row === endNodeRow && col === endNodeCol,\n    distance: Infinity,\n    totalDistance: Infinity,\n    isVisited: false,\n    isShortest: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst PathfindingVisualizer = () => {\n  //   State\n  const [grid, setGrid] = useState([]);\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n  const [numRows, setNumRows] = useState(initialNumRows);\n  const [numCols, setNumCols] = useState(initialNumCols);\n  const [speed, setSpeed] = useState(10);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n  const [mazeSpeed, setMazeSpeed] = useState(10);\n  const [visualizing, setVisualizing] = useState(false);\n  const [creatingMaze, setCreatingMaze] = useState(false);\n\n  // Get the initial width and height\n  const getDimensions = () => {\n    setWidth(window.innerWidth);\n    setHeight(window.innerHeight);\n  };\n\n  // Sets the maze speed and path speeds\n  const getSpeed = (path, maze) => {\n    setSpeed(path);\n    setMazeSpeed(maze);\n  };\n\n  // Creates a new grid with walls\n  const newGridWithWalls = (grid, row, col) => {\n    let newGrid = grid.slice();\n    let node = grid[row][col];\n    let newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  // Creates a new grid with mazes.\n  const newGridWithMaze = (grid, walls) => {\n    let newGrid = grid.slice();\n    for (let wall of walls) {\n      let node = grid[wall[0]][wall[1]];\n      let newNode = {\n        ...node,\n        isWall: true,\n      };\n      newGrid[wall[0]][wall[1]] = newNode;\n    }\n    return newGrid;\n  };\n\n  // Erases the path on the screen\n  const getGridWithoutPath = (grid) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          distance: Infinity,\n          totalDistance: Infinity,\n          isVisited: false,\n          isShortest: false,\n          previousNode: null,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    return newGrid;\n  };\n\n  const updateNodesForRender = (\n    grid,\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    let newGrid = grid.slice();\n    for (let node of visitedNodesInOrder) {\n      if (\n        (node.row === startNodeRow && node.col === startNodeCol) ||\n        (node.row === endNodeRow && node.col === endNodeCol)\n      )\n        continue;\n      let newNode = {\n        ...node,\n        isVisited: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n    for (let node of nodesInShortestPathOrder) {\n      if (node.row === endNodeRow && node.col === endNodeCol) {\n        return newGrid;\n      }\n      let newNode = {\n        ...node,\n        isVisited: false,\n        isShortest: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  };\n\n  const getVisitedNodesInOrder = (\n    visitedNodesInOrderStart,\n    visitedNodesInOrderEnd\n  ) => {\n    let visitedNodesInOrder = [];\n    let longest = Math.max(\n      visitedNodesInOrderStart.length,\n      visitedNodesInOrderEnd.length\n    );\n    for (let i = 0; i < longest; i++) {\n      if (visitedNodesInOrderStart[i] !== undefined) {\n        visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n      }\n      if (visitedNodesInOrderEnd[i] !== undefined) {\n        visitedNodesInOrder.push(visitedNodesInOrderEnd[i]);\n      }\n    }\n    return visitedNodesInOrder;\n  };\n\n  const updateSpeed = (path, maze) => {\n    setSpeed(path);\n    setMazeSpeed(maze);\n  };\n\n  //On resize, getDimensions again and setGrid\n  useEffect(() => {\n    window.addEventListener(\"resize\", getDimensions);\n    const grid = createInitialGrid(numRows, numCols);\n    setGrid(grid);\n  }, [numRows, numCols]);\n\n  // Functions to handle mouse presses and wall building\n  const handleMouseDown = (row, col) => {\n    const newGrid = newGridWithWalls(grid, row, col);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n    console.log(\"Mouse Pressed.\");\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (mouseIsPressed) {\n      const newGrid = newGridWithWalls(grid, row, col);\n      setGrid(newGrid);\n      setMouseIsPressed(true);\n    }\n  };\n\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  // Functions that clean up the grid.\n  const clearGrid = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          !(\n            (row === startNodeRow && col === startNodeCol) ||\n            (row === endNodeRow && col === endNodeCol)\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = createInitialGrid(numRows, numCols);\n    setGrid(newGrid);\n    setVisualizing(false);\n    setCreatingMaze(false);\n  };\n\n  const clearPath = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node node-shortest-path\"\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getGridWithoutPath(grid);\n    setGrid(newGrid);\n    setVisualizing(false);\n    setCreatingMaze(false);\n  };\n\n  // Animation functions\n  function animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder) {\n    if (nodesInShortestPathOrder.length === 1) {\n      setVisualizing(false);\n    }\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n          setVisualizing(false);\n        }, i * (3 * speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * speed));\n    }\n  }\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = grid.slice();\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    setGrid(newGrid);\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  const animateRandomWalk = (visitedNodesInOrder) => {\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          setVisualizing(false);\n        }, i * speed);\n        return;\n      }\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length - 1) {\n        // End Node\n        setTimeout(() => {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-end-reached\";\n        }, i * speed);\n        continue;\n      }\n      // Visited Node\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  function animateBidirectionalAlgorithm(\n    visitedNodesInOrderStart,\n    visitedNodesInOrderEnd,\n    nodesInShortestPathOrder,\n    isShortedPath\n  ) {\n    let len = Math.max(\n      visitedNodesInOrderStart.length,\n      visitedNodesInOrderEnd.length\n    );\n    for (let i = 1; i <= len; i++) {\n      let nodeA = visitedNodesInOrderStart[i];\n      let nodeB = visitedNodesInOrderEnd[i];\n      if (i === visitedNodesInOrderStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(\n            visitedNodesInOrderStart,\n            visitedNodesInOrderEnd\n          );\n          if (isShortedPath) {\n            animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          } else {\n            setVisualizing(false);\n          }\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        if (nodeA !== undefined) {\n          document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\n            \"node node-visited\";\n        }\n        if (nodeB !== undefined) {\n          document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\n            \"node node-visited\";\n        }\n      }, i * speed);\n    }\n  }\n\n  // Visualize Functions\n  const visualizeDijkstra = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDijkstra(endNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  };\n\n  const visualizeAStar = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = aStar(grid, startNode, endNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderAStar(endNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  };\n\n  const visualizeBFS = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = breadthFirstSearch(grid, startNode, endNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBFS(endNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  };\n\n  const visualizeDFS = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, endNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderDFS(endNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  };\n\n  const visualizeRandomWalk = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = randomWalk(grid, startNode, endNode);\n      animateRandomWalk(visitedNodesInOrder);\n    }, speed);\n  };\n\n  const visualizeGreedyBFS = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = greedyBestFirstSearch(\n        grid,\n        startNode,\n        endNode\n      );\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderGBFS(endNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  };\n\n  const visualizeBidirectionalGreedySearch = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setVisualizing(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const visitedNodesInOrder = bidirectionalGreedySearch(\n        grid,\n        startNode,\n        endNode\n      );\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderEnd = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      let firstNode =\n        visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1];\n      let secondNode =\n        visitedNodesInOrderEnd[visitedNodesInOrderEnd.length - 1];\n      const nodesInShortestPathOrder = getNodesInShortestPathOrderBGS(\n        firstNode,\n        secondNode\n      );\n      animateBidirectionalAlgorithm(\n        visitedNodesInOrderStart,\n        visitedNodesInOrderEnd,\n        nodesInShortestPathOrder,\n        isShortedPath\n      );\n    }, speed);\n  };\n\n  // Animate and Generate Maze Functions\n\n  const animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          clearGrid();\n          let newGrid = newGridWithMaze(grid, walls);\n          setGrid(newGrid);\n          setCreatingMaze(false);\n        }, i * mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * mazeSpeed);\n    }\n  };\n\n  const generateRandomMaze = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setCreatingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const walls = randomMaze(grid, startNode, endNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  };\n\n  const generateRecursiveDivisionMaze = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setCreatingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const walls = recursiveDivisionMaze(grid, startNode, endNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  };\n\n  const generateVerticalMaze = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setCreatingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const walls = verticalMaze(grid, startNode, endNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  };\n\n  const generateHorizontalMaze = () => {\n    if (visualizing || creatingMaze) {\n      return;\n    }\n    setCreatingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[startNodeRow][startNodeCol];\n      const endNode = grid[endNodeRow][endNodeCol];\n      const walls = horizontalMaze(grid, startNode, endNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  };\n\n  return (\n    <>\n      <ToolBar\n        visualizing={visualizing}\n        creatingMaze={creatingMaze}\n        visualizeDijkstra={visualizeDijkstra}\n        visualizeAStar={visualizeAStar}\n        visualizeGreedyBFS={visualizeGreedyBFS}\n        visualizeDFS={visualizeDFS}\n        visualizeBFS={visualizeBFS}\n        visualizeBidirectionalGreedySearch={visualizeBidirectionalGreedySearch}\n        visualizeRandomWalk={visualizeRandomWalk}\n        generateRandomMaze={generateRandomMaze}\n        generateHorizontalMaze={generateHorizontalMaze}\n        generateVerticalMaze={generateVerticalMaze}\n        generateRecursiveDivisionMaze={generateRecursiveDivisionMaze}\n        clearGrid={clearGrid}\n        clearPath={clearPath}\n        updateSpeed={updateSpeed}\n      />\n      <div\n        className={visualizing || creatingMaze ? \"grid-visualizing\" : \"grid\"}\n      >\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const {\n                  row,\n                  col,\n                  isStart,\n                  isEnd,\n                  isVisited,\n                  isShortest,\n                  isWall,\n                } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isEnd={isEnd}\n                    isVisited={isVisited}\n                    isShortest={isShortest}\n                    isWall={isWall}\n                    width={width}\n                    height={height}\n                    numRows={numRows}\n                    numCols={numCols}\n                    onMouseDown={(row, col) => handleMouseDown(row, col)}\n                    onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                    onMouseUp={() => handleMouseUp()}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default PathfindingVisualizer;\n","export const randomMaze = (grid, startNode, endNode) => {\n  if (!startNode || !endNode || startNode === endNode) {\n    return false;\n  }\n  let walls = [];\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length; col++) {\n      if (\n        (row === startNode.row && col === startNode.col) ||\n        (row === endNode.row && col === endNode.col)\n      )\n        continue;\n      if (Math.random() < 0.33) {\n        walls.push([row, col]);\n      }\n    }\n  }\n  walls.sort(() => Math.random() - 0.5);\n  return walls;\n};\n","import \"bootstrap\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"bootstrap/dist/js/bootstrap.js\";\nimport $ from \"jquery\";\nimport Popper from \"popper.js\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n\nimport reportWebVitals from \"./reportWebVitals\";\nimport PathfindingVisualizer from \"./pathfindingVisualizer/pathfindingVisualizer.component\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <PathfindingVisualizer />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}